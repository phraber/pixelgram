#' Apply a closure function generated by create.timepoint.parser to leaf names.
#'
#' @param seq_names A vector or list of type character, for parsing.
#' @param timepoints_parser A closure function.
#' @param uniquify Option to return a normalized (non-redundant) list of parsed entries.
#' @param refseq_name If this sequence name is in the alignment, its name will not be parsed, but the corresponding entry will be assigned NULL instead.
#' @param name_list Should the resulting list be named after the input sequences?
#'
#' @return A (possibly named) list of fields parsed from the input sequence names.
#'
#' @export
parse.timepoints <- function(seq_names=NULL, timepoints_parser=NULL, 
		 uniquify=F, refseq_name=NULL, name_list=F) {

    if (is.null(timepoints_parser) | is.null(seq_names) |
        !is.function(timepoints_parser) | !is.character(seq_names))
      return ( NULL )

    if (!is.null(refseq_name))
      if (refseq_name %in% seq_names)
        if (length(which(seq_names) == refseq_name) == 1)
          seq_names[which(seq_names) == refseq_name] = NULL

    timepoint_per_sequence <- sapply(1:length(seq_names), function(i)
        timepoints_parser(seq_names[i]))

    if (name_list)
        names(timepoint_per_sequence) = seq_names

    if (length(which(is.null(timepoint_per_sequence))) > 1)
      paste("ERROR in parse.timepoints(): Some names not parsed\n",
            paste(seq_names[which(is.null(timepoint_per_sequence))],
                  collapse=','), '\n')

    if (uniquify) {
	return ( as.character(sort(
#		    as.numeric(
			unique(#gsub("^[A-Za-z]", "",
	    timepoint_per_sequence))))#) #)
    } else {
	return ( #gsub("^[A-Za-z]", "",
	    timepoint_per_sequence)# )
    }
}
